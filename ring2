# --- Do not remove these libs ---
from freqtrade.strategy import IStrategy
from pandas import DataFrame
from freqtrade.persistence import Trade
from datetime import datetime, timedelta

import pandas as pd
import talib.abstract as ta
import freqtrade.vendor.qtpylib.indicators as qtpylib

class RingRong(IStrategy):
    timeframe = "5m"
    can_short: bool = True

    minimal_roi = {
        "120": 0.20,
        "60": 0.10,
        "0": 0.05
    }

    stoploss = -0.10
    use_custom_stoploss = True
    startup_candle_count = 200

    # Define timeframe for analysis
    informative_timeframes = {
        "15m": "15m",
        "1h": "1h",
        "4h": "4h"
    }

    def informative_pairs(self):
        pairs = ["BTC/USDT", "ETH/USDT"]
        informative_pairs = [(pair, tf) for pair in pairs for tf in self.informative_timeframes.values()]
        informative_pairs.append(("BTC/USDT", "5m"))
        informative_pairs.append(("ETH/USDT", "5m"))
        return informative_pairs

    def populate_indicators(self, dataframe: DataFrame, metadata: dict) -> DataFrame:
        # Main timeframe indicators (5m)
        dataframe["adx"] = ta.ADX(dataframe, timeperiod=14)
        dataframe["short"] = ta.EMA(dataframe, timeperiod=50)
        dataframe["long"] = ta.EMA(dataframe, timeperiod=200)
        dataframe["rsi"] = ta.RSI(dataframe, timeperiod=14)
        dataframe["mfi"] = ta.MFI(dataframe)
        dataframe["sma_200"] = ta.SMA(dataframe, timeperiod=200)
        dataframe['atr'] = ta.ATR(dataframe, timeperiod=14)

        # Bollinger Bands
        bollinger = qtpylib.bollinger_bands(qtpylib.typical_price(dataframe), window=20, stds=2)
        dataframe['bb_lowerband'] = bollinger['lower']
        dataframe['bb_middleband'] = bollinger['mid']
        dataframe['bb_upperband'] = bollinger['upper']

        # MACD for trend confirmation
        macd = ta.MACD(dataframe)
        dataframe["macd"] = macd["macd"]
        dataframe["macdsignal"] = macd["macdsignal"]

        # Informative timeframes
        for tf_name, tf in self.informative_timeframes.items():
            for pair in ["BTC/USDT", "ETH/USDT"]:
                informative = self.dp.get_pair_dataframe(pair, tf)
                informative[f"ema_{tf}"] = ta.EMA(informative, timeperiod=50)
                informative[f"sma_200_{tf}"] = ta.SMA(informative, timeperiod=200)

                dataframe[f"trend_{pair}_{tf}"] = (
                    informative["close"] > informative[f"sma_200_{tf}"]
                )
                dataframe[f"trend_strength_{pair}_{tf}"] = (
                    (informative["close"] > informative[f"ema_{tf}"])
                    & (informative[f"ema_{tf}"] > informative[f"sma_200_{tf}"])
                )

        return dataframe

    def populate_entry_trend(self, dataframe: DataFrame, metadata: dict) -> DataFrame:
        dataframe.loc[
            (
                (dataframe["adx"] > 20)  # Lowering the threshold
                & (dataframe["short"] > dataframe["long"])
                & (dataframe["close"] > dataframe["sma_200"])
                & (dataframe["close"] <= dataframe['bb_lowerband'])
                & (dataframe["rsi"] < 35)  # Slightly higher RSI for entry
                & (dataframe["mfi"] < 25)  # Slightly higher MFI for entry
                & (dataframe["macd"] > dataframe["macdsignal"])  # MACD for confirmation
                & (dataframe["trend_BTC/USDT_4h"] == True)
                & (dataframe["trend_strength_BTC/USDT_1h"] == True)
                & (dataframe["trend_strength_BTC/USDT_15m"] == True)
                & (dataframe["volume"] > 0)
            ),
            ["enter_long", "enter_tag"],
        ] = (1, "adx_cross_bullish")

        dataframe.loc[
            (
                (dataframe["adx"] > 20)  # Lowering the threshold
                & (dataframe["short"] < dataframe["long"])
                & (dataframe["close"] < dataframe["sma_200"])
                & (dataframe["close"] >= dataframe['bb_upperband'])
                & (dataframe["rsi"] > 65)  # Slightly lower RSI for entry
                & (dataframe["mfi"] > 75)  # Slightly lower MFI for entry
                & (dataframe["macd"] < dataframe["macdsignal"])  # MACD for confirmation
                & (dataframe["trend_BTC/USDT_4h"] == False)
                & (dataframe["trend_strength_BTC/USDT_1h"] == False)
                & (dataframe["trend_strength_BTC/USDT_15m"] == False)
                & (dataframe["volume"] > 0)
            ),
            ["enter_short", "enter_tag"],
        ] = (1, "adx_cross_bearish")

        return dataframe

    def populate_exit_trend(self, dataframe: DataFrame, metadata: dict) -> DataFrame:
        dataframe.loc[
            (
                (dataframe["adx"] < 20)
                | (qtpylib.crossed_below(dataframe["short"], dataframe["long"]))
                | (dataframe["close"] < dataframe["sma_200"])
                | (dataframe["close"] > dataframe['bb_middleband'])
                | (dataframe["rsi"] > 50)
                | (dataframe["mfi"] > 50)
                | (dataframe["atr"] < 0.005)  # Low ATR indicating low volatility
            )
            &
            (dataframe["volume"] > 0),
            ["exit_long", "exit_tag"],
        ] = (1, "exit_long")

        dataframe.loc[
            (
                (dataframe["adx"] < 20)
                | (qtpylib.crossed_above(dataframe["short"], dataframe["long"]))
                | (dataframe["close"] > dataframe["sma_200"])
                | (dataframe["close"] < dataframe['bb_middleband'])
                | (dataframe["rsi"] < 50)
                | (dataframe["mfi"] < 50)  
                | (dataframe["atr"] < 0.005)  # Low ATR indicating low volatility
            )
            &
            (dataframe["volume"] > 0),
            ["exit_short", "exit_tag"],
        ] = (1, "exit_short")

        return dataframe

    def custom_stoploss(self, pair: str, trade: Trade, current_time: datetime, current_rate: float,
                        current_profit: float, **kwargs) -> float:
        """
        Custom stoploss with trailing stop based on ATR.
        """
        # Calculate ATR
        dataframe, _ = self.dp.get_analyzed_dataframe(pair, self.timeframe)
        atr = dataframe['atr'].iloc[-1]

        # Adjust the stoploss to ATR levels
        stoploss = max(-0.05, -1.5 * atr)

        # Ensure it doesn't exceed the configured stoploss
        return stoploss
